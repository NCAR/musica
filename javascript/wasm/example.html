<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MUSICA WASM Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }

        .info {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .loading {
            color: #666;
        }

        .version {
            font-weight: bold;
            color: #007bff;
        }

        .error {
            color: #dc3545;
            background-color: #f8d7da;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
</head>

<body>
    <h1>MUSICA WASM Example</h1>
    <div id="content">
        <p class="loading">Loading MUSICA WASM module...</p>
    </div>

    <script type="module">
        import * as musica from '../index.js';

        // Initialize and use the MUSICA package (uses WASM backend internally)
        async function initMUSICA() {
            const contentDiv = document.getElementById('content');

            try {
                await musica.initModule();

                // Get versions
                const musicaVersion = await musica.getVersion();
                const micmVersion = await musica.getMicmVersion();

                // Display the results
                contentDiv.innerHTML = `
                    <div class="info">
                        <h2>✅ MUSICA WASM Module Loaded Successfully</h2>
                        <p><strong>MUSICA Version:</strong> <span class="version">${musicaVersion}</span></p>
                        <p><strong>MICM Version:</strong> <span class="version">${micmVersion}</span></p>
                    </div>
                    <div class="info">
                        <h3>About this example</h3>
                        <p>This demonstrates the MUSICA library compiled to WebAssembly running directly in your browser.</p>
                        <p>No server-side processing is required - all computation happens in your browser!</p>
                    </div>
                `;

                // Brief Lorenz description and mapping to chemistry
                const lorenzDesc = document.createElement('div');
                lorenzDesc.className = 'info';
                lorenzDesc.innerHTML = `
                    <h3>Lorenz System</h3>
                    <p>The Lorenz equations are a simple 3D dynamical system:</p>
                    <p>$$\\frac{dx}{dt} = \\sigma (y - x)\\\\
                    \\frac{dy}{dt} = x (\\rho - z) - y\\\\
                    \\frac{dz}{dt} = x y - \\beta z$$</p>
                    <p>In this example we represent variables <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong> as chemical species. Nonlinear interactions are approximated with user-defined reactions and tunable rate parameters:</p>
                    <ul>
                      <li><strong>σ</strong>: exchange terms between X and Y (reactions <em>Y_to_X</em> and <em>X_to_Y</em>).</li>
                      <li><strong>ρ</strong>: promotes production of Y from X (reaction <em>X_autocatalytic_Y</em>).</li>
                      <li><strong>β</strong>: decay of Z (reaction <em>Z_decay</em>).</li>
                      <li>Additional reactions model coupling and decay: <em>X_Z_quench</em>, <em>Y_decay</em>, <em>XY_to_Z</em>.</li>
                    </ul>
                                `; // Original line ends here
                lorenzDesc.innerHTML = `
                                        <h3>Lorenz System</h3>
                                        <p>The Lorenz equations are a simple 3D dynamical system:</p>
                                        <p>$$\\frac{dx}{dt} = \\sigma (y - x)\\\\
                                        \\frac{dy}{dt} = x (\\rho - z) - y\\\\
                                        \\frac{dz}{dt} = x y - \\beta z$$</p>
                                        <p>In this example we represent variables <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong> as chemical species. Nonlinear interactions are approximated with user-defined reactions and tunable rate parameters.</p>

                                        <h4>Chemical Representation</h4>
                                        <p>Each term in the Lorenz equations is approximated by one or more user-defined reactions. The mapping below explains which reactions and parameters correspond to the main terms:</p>
                                        <ul>
                                            <li><strong>Exchange (σ (y - x))</strong>: modeled by two first-order exchange reactions <em>Y_to_X</em> and <em>X_to_Y</em>. Setting both rates to <em>σ</em> approximates the linear coupling that drives x toward y and vice versa.</li>

                                            <li><strong>Production &amp; coupling in y (<em>x(ρ - z)</em>)</strong>:
                                                <ul>
                                                    <li><em>X_autocatalytic_Y</em> (rate ~ <em>ρ</em>) represents production of Y driven by X (the x·ρ term).</li>
                                                    <li><em>X_Z_quench</em> and <em>XY_to_Z</em> introduce coupling with Z: when Z is large, <em>X_Z_quench</em> reduces X (mimicking the −x·z term in combination with other steps), while <em>XY_to_Z</em> produces Z from X and Y to capture the x·y → z interaction that feeds back into Y dynamics via Z.</li>
                                                    <li><em>Y_decay</em> provides a linear loss term for Y (the −y term).</li>
                                                </ul>
                                            </li>

                                            <li><strong>Z dynamics (x·y − β z)</strong>: production of Z from the interaction of X and Y is modeled with <em>XY_to_Z</em> (the x·y term), and removal of Z is modeled with <em>Z_decay</em> with rate parameter <em>β</em>.</li>
                                        </ul>

                                        <p><em>Note:</em> This chemical encoding is an approximation: continuous nonlinear terms are represented by combinations of discrete user-defined reactions and tunable rates to mimic the Lorenz flow within the MUSICA/MICM framework.</p>
                                `;
                // contentDiv.appendChild(lorenzDesc);

                // Attempt to render LaTeX in the lorenz description when KaTeX is ready
                function tryRenderLorenz() {
                    if (window.renderMathInElement) {
                        renderMathInElement(lorenzDesc, {
                            delimiters: [
                                { left: '$$', right: '$$', display: true },
                                { left: '$', right: '$', display: false }
                            ]
                        });
                    } else {
                        setTimeout(tryRenderLorenz, 50);
                    }
                }
                // tryRenderLorenz();

                // Run a short in-browser simulation test similar to the unit test
                try {
                    // Build a simple mechanism and prepare for interactive simulation
                    const { MICM } = musica;
                    const { types, reactionTypes, Mechanism } = musica.mechanismConfiguration;
                    const { Species, Phase, ReactionComponent } = types;

                    // Create species and phases (Lorenz attractor mapping)
                    const X = new Species({ name: 'X' });
                    const Y = new Species({ name: 'Y' });
                    const Z = new Species({ name: 'Z' });

                    const gas = new Phase({ name: 'gas', species: [X, Y, Z] });

                    // equations from this paper: https://link.springer.com/article/10.1007/s11071-025-11622-1 
                    const reactions = [
                        // α1 : X → ∅
                        new reactionTypes.UserDefined({
                            name: 'X_decay',
                            gas_phase: 'gas',
                            reactants: [new ReactionComponent({ species_name: 'X' })],
                            products: []
                        }),

                        // α2 : Y → X + Y
                        new reactionTypes.UserDefined({
                            name: 'Y_to_XY',
                            gas_phase: 'gas',
                            reactants: [new ReactionComponent({ species_name: 'Y' })],
                            products: [
                                new ReactionComponent({ species_name: 'X' }),
                                new ReactionComponent({ species_name: 'Y' })
                            ]
                        }),

                        // α3 : ∅ → Y
                        new reactionTypes.UserDefined({
                            name: 'Y_source',
                            gas_phase: 'gas',
                            reactants: [],
                            products: [new ReactionComponent({ species_name: 'Y' })]
                        }),

                        // α4 : Y → ∅
                        new reactionTypes.UserDefined({
                            name: 'Y_sink',
                            gas_phase: 'gas',
                            reactants: [new ReactionComponent({ species_name: 'Y' })],
                            products: []
                        }),

                        // α5 : X + Y → X + 2Y
                        new reactionTypes.UserDefined({
                            name: 'XY_to_X2Y',
                            gas_phase: 'gas',
                            reactants: [
                                new ReactionComponent({ species_name: 'X' }),
                                new ReactionComponent({ species_name: 'Y' })
                            ],
                            products: [
                                new ReactionComponent({ species_name: 'X' }),
                                new ReactionComponent({ species_name: 'Y' }),
                                new ReactionComponent({ species_name: 'Y' })
                            ]
                        }),

                        // α6 : Y + Z → 2Y
                        new reactionTypes.UserDefined({
                            name: 'YZ_to_2Y',
                            gas_phase: 'gas',
                            reactants: [
                                new ReactionComponent({ species_name: 'Y' }),
                                new ReactionComponent({ species_name: 'Z' })
                            ],
                            products: [
                                new ReactionComponent({ species_name: 'Y' }),
                                new ReactionComponent({ species_name: 'Y' })
                            ]
                        }),

                        // α7 : X + Y + Z → X + 2Z
                        new reactionTypes.UserDefined({
                            name: 'XYZ_to_X2Z',
                            gas_phase: 'gas',
                            reactants: [
                                new ReactionComponent({ species_name: 'X' }),
                                new ReactionComponent({ species_name: 'Y' }),
                                new ReactionComponent({ species_name: 'Z' })
                            ],
                            products: [
                                new ReactionComponent({ species_name: 'X' }),
                                new ReactionComponent({ species_name: 'Z' }),
                                new ReactionComponent({ species_name: 'Z' })
                            ]
                        }),

                        // α8 : ∅ → Z
                        new reactionTypes.UserDefined({
                            name: 'Z_source',
                            gas_phase: 'gas',
                            reactants: [],
                            products: [new ReactionComponent({ species_name: 'Z' })]
                        }),

                        // α9 : Z → 2Z
                        new reactionTypes.UserDefined({
                            name: 'Z_autocatalytic',
                            gas_phase: 'gas',
                            reactants: [new ReactionComponent({ species_name: 'Z' })],
                            products: [
                                new ReactionComponent({ species_name: 'Z' }),
                                new ReactionComponent({ species_name: 'Z' })
                            ]
                        }),

                        // α10 : X + Z → X
                        new reactionTypes.UserDefined({
                            name: 'XZ_quench',
                            gas_phase: 'gas',
                            reactants: [
                                new ReactionComponent({ species_name: 'X' }),
                                new ReactionComponent({ species_name: 'Z' })
                            ],
                            products: [new ReactionComponent({ species_name: 'X' })]
                        })

                    ];

                    const mechanism = new Mechanism({
                        name: 'Lorenz Polynomial CRN',
                        version: '1.0.0',
                        species: [X, Y, Z],
                        phases: [gas],
                        reactions
                    });

                    const micm = MICM.fromMechanism(mechanism);
                    const state = micm.createState(1);

                    // Set conditions and rate parameters once
                    state.setConditions({ temperatures: [298.15], pressures: [101325.0], air_densities: [1.0] });

                    let mu = 1.0 / 100;

                    state.setUserDefinedRateParameters({
                        'USER.X_decay': 10,
                        'USER.Y_to_XY': 10,
                        'USER.Y_source': 1 / mu,
                        'USER.Y_sink': 1 / mu + 29,
                        'USER.XY_to_X2Y': 1 + mu * 28,
                        'USER.YZ_to_2Y': 1,
                        'USER.XYZ_to_X2Z': mu,
                        'USER.Z_source': 8 / (3 * mu),
                        'USER.Z_autocatalytic': 1 / mu - 8 / 3,
                        'USER.XZ_quench': 1
                    });

                    // Create interactive controls
                    const controls = document.createElement('div');
                    controls.className = 'info';
                    controls.innerHTML = '<h3>Initial Concentrations</h3>';

                    function createSlider(name, min, max, step, initial) {
                        const wrapper = document.createElement('div');
                        wrapper.style.marginTop = '8px';

                        const label = document.createElement('label');
                        label.textContent = name + ': ';
                        label.style.marginRight = '8px';

                        const valueSpan = document.createElement('span');
                        valueSpan.textContent = String(initial);
                        valueSpan.style.fontWeight = 'bold';
                        valueSpan.style.marginLeft = '8px';

                        const input = document.createElement('input');
                        input.type = 'range';
                        input.min = String(min);
                        input.max = String(max);
                        input.step = String(step);
                        input.value = String(initial);
                        input.style.width = '60%';
                        input.style.marginLeft = '12px';

                        wrapper.appendChild(label);
                        wrapper.appendChild(input);
                        wrapper.appendChild(valueSpan);

                        return { wrapper, input, valueSpan };
                    }

                    // Default initial concentrations (Lorenz typical small values)
                    const X0 = 1.0;
                    const Y0 = 28.0 * X0;
                    const Z0 = X0 * X0;

                    const sliderX = createSlider('X', -30, 30, 0.01, X0);
                    const sliderY = createSlider('Y', -30, 30, 0.01, Y0);
                    const sliderZ = createSlider('Z', -10, 50, 0.01, Z0);

                    controls.appendChild(sliderX.wrapper);
                    controls.appendChild(sliderY.wrapper);
                    controls.appendChild(sliderZ.wrapper);

                    contentDiv.appendChild(controls);

                    // Prepare results table (reused on each run)
                    const resultsContainer = document.createElement('div');
                    resultsContainer.className = 'info';
                    resultsContainer.innerHTML = '<h3>Simulation Results (10 solves)</h3>';

                    const table = document.createElement('table');
                    table.style.width = '100%';
                    table.style.borderCollapse = 'collapse';
                    table.style.marginTop = '8px';

                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    ['Time', 'X', 'Y', 'Z'].forEach(h => {
                        const th = document.createElement('th');
                        th.textContent = h;
                        th.style.border = '1px solid #ddd';
                        th.style.padding = '6px';
                        th.style.textAlign = 'left';
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);
                    table.appendChild(thead);

                    const tbody = document.createElement('tbody');
                    table.appendChild(tbody);

                    resultsContainer.appendChild(table);
                    contentDiv.appendChild(resultsContainer);

                    // Hide the results table by default and add a toggle in controls
                    resultsContainer.style.display = 'none';

                    const tableToggleWrapper = document.createElement('div');
                    tableToggleWrapper.style.marginTop = '8px';
                    const toggleLabel = document.createElement('label');
                    const toggle = document.createElement('input');
                    toggle.type = 'checkbox';
                    toggle.checked = false; // default hidden
                    toggleLabel.appendChild(toggle);
                    toggleLabel.appendChild(document.createTextNode(' Show results table'));
                    tableToggleWrapper.appendChild(toggleLabel);
                    controls.appendChild(tableToggleWrapper);

                    toggle.addEventListener('change', () => {
                        resultsContainer.style.display = toggle.checked ? '' : 'none';
                    });

                    // Create plot container (Lorenz attractor 3D plot)
                    const plotContainer = document.createElement('div');
                    plotContainer.className = 'info';
                    plotContainer.innerHTML = '<h3>Lorenz Attractor (3D)</h3>';
                    const plotDiv = document.createElement('div');
                    plotDiv.id = 'lorenz-plot';
                    plotDiv.style.width = '100%';
                    plotDiv.style.height = '420px';

                    plotContainer.appendChild(plotDiv);
                    contentDiv.appendChild(plotContainer);

                    // Function to read slider values
                    function readSliderValues() {
                        const x = parseFloat(sliderX.input.value);
                        const y = parseFloat(sliderY.input.value);
                        const z = parseFloat(sliderZ.input.value);
                        return { X: x, Y: y, Z: z };
                    }

                    // Plotly plot updater: draws Lorenz attractor as a 3D trajectory
                    function updatePlot(times, Xseries, Yseries, Zseries) {
                        const plotDiv = document.getElementById('lorenz-plot');
                        if (!plotDiv) return;

                        const traj = {
                            x: Xseries,
                            y: Yseries,
                            z: Zseries,
                            mode: 'lines',
                            type: 'scatter3d',
                            line: { width: 2, color: '#1f77b4' },
                            name: 'trajectory'
                        };

                        const lastIdx = Xseries.length - 1;
                        const current = {
                            x: [Xseries[lastIdx]],
                            y: [Yseries[lastIdx]],
                            z: [Zseries[lastIdx]],
                            mode: 'markers',
                            type: 'scatter3d',
                            marker: { size: 4, color: '#d62728' },
                            name: 'current'
                        };

                        const layout = {
                            margin: { l: 0, r: 0, b: 0, t: 0 },
                            scene: {
                                xaxis: { title: 'X' },
                                yaxis: { title: 'Y' },
                                zaxis: { title: 'Z' }
                            },
                            autosize: true,
                            height: 420
                        };

                        Plotly.newPlot(plotDiv, [traj, current], layout, { responsive: true });
                    }

                    // Run the simulation and populate the results table + plot
                    function runSimulation(steps = 1000, timeStep = 0.01, burnout = 100) {
                        // Reset table
                        tbody.innerHTML = '';

                        // Reset concentrations from sliders
                        const vals = readSliderValues();
                        state.setConcentrations({ X: [vals.X], Y: [vals.Y], Z: [vals.Z] });

                        let cumulativeTime = 0.0;

                        const times = [];
                        const Xs = [];
                        const Ys = [];
                        const Zs = [];

                        for (let i = 0; i < steps; i++) {
                            micm.solve(state, timeStep);
                            cumulativeTime += timeStep;

                            const concentrations = state.getConcentrations();
                            function val(spec) {
                                const v = concentrations[spec];
                                if (Array.isArray(v)) return v[0];
                                return v;
                            }

                            const xVal = val('X');
                            const yVal = val('Y');
                            const zVal = val('Z');

                            if (i < burnout) continue; // skip initial transient
                            times.push(cumulativeTime);
                            Xs.push(xVal);
                            Ys.push(yVal);
                            Zs.push(zVal);

                            const row = document.createElement('tr');
                            [cumulativeTime.toFixed(2), xVal, yVal, zVal].forEach(cellVal => {
                                const td = document.createElement('td');
                                td.textContent = String(cellVal);
                                td.style.border = '1px solid #ddd';
                                td.style.padding = '6px';
                                row.appendChild(td);
                            });
                            tbody.appendChild(row);
                        }

                        updatePlot(times, Xs, Ys, Zs);
                    }

                    // Wire sliders to rerun simulation on input
                    [sliderX, sliderY, sliderZ].forEach(s => {
                        s.input.addEventListener('input', () => {
                            s.valueSpan.textContent = s.input.value;
                            runSimulation();
                        });
                    });

                    // Initial run
                    runSimulation();
                } catch (err) {
                    const errDiv = document.createElement('div');
                    errDiv.className = 'error';
                    errDiv.innerHTML = `<h2>❌ Simulation Error</h2><p>${err.message}</p>`;
                    contentDiv.appendChild(errDiv);
                    console.error(err);
                }
            } catch (error) {
                contentDiv.innerHTML = `
                    <div class="error">
                        <h2>❌ Error Loading MUSICA WASM</h2>
                        <p>${error.message}</p>
                        <p>Make sure you've built the WASM module and are serving this page over HTTP (not file://).</p>
                    </div>
                `;
                console.error('Error:', error);
            }
        }

        // Start initialization when page loads
        initMUSICA();
    </script>
</body>

</html>