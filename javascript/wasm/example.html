<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MUSICA WASM Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }

        .info {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .loading {
            color: #666;
        }

        .version {
            font-weight: bold;
            color: #007bff;
        }

        .error {
            color: #dc3545;
            background-color: #f8d7da;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <h1>MUSICA WASM Example</h1>
    <div id="content">
        <p class="loading">Loading MUSICA WASM module...</p>
    </div>

    <script type="module">
        import * as musica from '../index.js';

        // Initialize and use the MUSICA package (uses WASM backend internally)
        async function initMUSICA() {
            const contentDiv = document.getElementById('content');

            try {
                await musica.initModule();

                // Get versions
                const musicaVersion = await musica.getVersion();
                const micmVersion = await musica.getMicmVersion();

                // Display the results
                contentDiv.innerHTML = `
                    <div class="info">
                        <h2>✅ MUSICA WASM Module Loaded Successfully</h2>
                        <p><strong>MUSICA Version:</strong> <span class="version">${musicaVersion}</span></p>
                        <p><strong>MICM Version:</strong> <span class="version">${micmVersion}</span></p>
                    </div>
                    <div class="info">
                        <h3>About this example</h3>
                        <p>This demonstrates the MUSICA library compiled to WebAssembly running directly in your browser.</p>
                        <p>No server-side processing is required - all computation happens in your browser!</p>
                    </div>
                `;

                // Run a short in-browser simulation test similar to the unit test
                try {
                    // Build a simple mechanism and prepare for interactive simulation
                    const { MICM } = musica;
                    const { types, reactionTypes, Mechanism } = musica.mechanismConfiguration;
                    const { Species, Phase, ReactionComponent } = types;

                    // Create species and phases (Lorenz attractor mapping)
                    const X = new Species({ name: 'X' });
                    const Y = new Species({ name: 'Y' });
                    const Z = new Species({ name: 'Z' });

                    const gas = new Phase({ name: 'gas', species: [X, Y, Z] });

                    const reactions = [
                        new reactionTypes.UserDefined({
                            name: 'Y_to_X',
                            gas_phase: 'gas',
                            reactants: [new ReactionComponent({ species_name: 'Y' })],
                            products: [new ReactionComponent({ species_name: 'X' })]
                        }),
                        new reactionTypes.UserDefined({
                            name: 'X_to_Y',
                            gas_phase: 'gas',
                            reactants: [new ReactionComponent({ species_name: 'X' })],
                            products: [new ReactionComponent({ species_name: 'Y' })]
                        }),
                        new reactionTypes.UserDefined({
                            name: 'X_autocatalytic_Y',
                            gas_phase: 'gas',
                            reactants: [new ReactionComponent({ species_name: 'X' })],
                            products: [new ReactionComponent({ species_name: 'X' }), new ReactionComponent({ species_name: 'Y' })]
                        }),
                        new reactionTypes.UserDefined({
                            name: 'X_Z_quench',
                            gas_phase: 'gas',
                            reactants: [new ReactionComponent({ species_name: 'X' }), new ReactionComponent({ species_name: 'Z' })],
                            products: [new ReactionComponent({ species_name: 'Z' })]
                        }),
                        new reactionTypes.UserDefined({
                            name: 'Y_decay',
                            gas_phase: 'gas',
                            reactants: [new ReactionComponent({ species_name: 'Y' })],
                            products: []
                        }),
                        new reactionTypes.UserDefined({
                            name: 'XY_to_Z',
                            gas_phase: 'gas',
                            reactants: [new ReactionComponent({ species_name: 'X' }), new ReactionComponent({ species_name: 'Y' })],
                            products: [new ReactionComponent({ species_name: 'X' }), new ReactionComponent({ species_name: 'Y' }), new ReactionComponent({ species_name: 'Z' })]
                        }),
                        new reactionTypes.UserDefined({
                            name: 'Z_decay',
                            gas_phase: 'gas',
                            reactants: [new ReactionComponent({ species_name: 'Z' })],
                            products: []
                        })
                    ];

                    const mechanism = new Mechanism({
                        name: 'Lorenz Attractor',
                        version: '1.0.0',
                        species: [X, Y, Z],
                        phases: [gas],
                        reactions
                    });

                    const micm = MICM.fromMechanism(mechanism);
                    const state = micm.createState(1);

                    // Set conditions and rate parameters once
                    state.setConditions({ temperatures: [298.15], pressures: [101325.0], air_densities: [1.0] });
                    // state.setConcentrations({
                    //     'X': [0.75],
                    //     'Y': [0.0],
                    //     'Z': [0.4],
                    // });

                    // Lorenz parameters
                    const sigma = 10.0;
                    const rho = 28.0;
                    const beta = 8.0 / 3.0;

                    state.setUserDefinedRateParameters({
                        'USER.Y_to_X': sigma,
                        'USER.X_to_Y': sigma,
                        'USER.X_autocatalytic_Y': rho,
                        'USER.X_Z_quench': 1.0,
                        'USER.Y_decay': 1.0,
                        'USER.XY_to_Z': 1.0,
                        'USER.Z_decay': beta
                    });

                    // Create interactive controls
                    const controls = document.createElement('div');
                    controls.className = 'info';
                    controls.innerHTML = '<h3>Initial Concentrations</h3>';

                    function createSlider(name, min, max, step, initial) {
                        const wrapper = document.createElement('div');
                        wrapper.style.marginTop = '8px';

                        const label = document.createElement('label');
                        label.textContent = name + ': ';
                        label.style.marginRight = '8px';

                        const valueSpan = document.createElement('span');
                        valueSpan.textContent = String(initial);
                        valueSpan.style.fontWeight = 'bold';
                        valueSpan.style.marginLeft = '8px';

                        const input = document.createElement('input');
                        input.type = 'range';
                        input.min = String(min);
                        input.max = String(max);
                        input.step = String(step);
                        input.value = String(initial);
                        input.style.width = '60%';
                        input.style.marginLeft = '12px';

                        wrapper.appendChild(label);
                        wrapper.appendChild(input);
                        wrapper.appendChild(valueSpan);

                        return { wrapper, input, valueSpan };
                    }

                    // Default initial concentrations (Lorenz typical small values)
                    const sliderX = createSlider('X', -30, 30, 0.01, 0.0);
                    const sliderY = createSlider('Y', -30, 30, 0.01, 1.0);
                    const sliderZ = createSlider('Z', -10, 50, 0.01, 1.05);

                    controls.appendChild(sliderX.wrapper);
                    controls.appendChild(sliderY.wrapper);
                    controls.appendChild(sliderZ.wrapper);

                    contentDiv.appendChild(controls);

                    // Prepare results table (reused on each run)
                    const resultsContainer = document.createElement('div');
                    resultsContainer.className = 'info';
                    resultsContainer.innerHTML = '<h3>Simulation Results (10 solves)</h3>';

                    const table = document.createElement('table');
                    table.style.width = '100%';
                    table.style.borderCollapse = 'collapse';
                    table.style.marginTop = '8px';

                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    ['Time', 'X', 'Y', 'Z'].forEach(h => {
                        const th = document.createElement('th');
                        th.textContent = h;
                        th.style.border = '1px solid #ddd';
                        th.style.padding = '6px';
                        th.style.textAlign = 'left';
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);
                    table.appendChild(thead);

                    const tbody = document.createElement('tbody');
                    table.appendChild(tbody);

                    resultsContainer.appendChild(table);
                    contentDiv.appendChild(resultsContainer);

                    // Hide the results table by default and add a toggle in controls
                    resultsContainer.style.display = 'none';

                    const tableToggleWrapper = document.createElement('div');
                    tableToggleWrapper.style.marginTop = '8px';
                    const toggleLabel = document.createElement('label');
                    const toggle = document.createElement('input');
                    toggle.type = 'checkbox';
                    toggle.checked = false; // default hidden
                    toggleLabel.appendChild(toggle);
                    toggleLabel.appendChild(document.createTextNode(' Show results table'));
                    tableToggleWrapper.appendChild(toggleLabel);
                    controls.appendChild(tableToggleWrapper);

                    toggle.addEventListener('change', () => {
                        resultsContainer.style.display = toggle.checked ? '' : 'none';
                    });

                    // Create plot container (Lorenz attractor phase plot)
                    const plotContainer = document.createElement('div');
                    plotContainer.className = 'info';
                    plotContainer.innerHTML = '<h3>Lorenz Attractor (X vs Z)</h3>';
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '760');
                    svg.setAttribute('height', '320');
                    svg.style.width = '100%';
                    svg.style.maxWidth = '760px';
                    plotContainer.appendChild(svg);
                    contentDiv.appendChild(plotContainer);

                    // Function to read slider values
                    function readSliderValues() {
                        const x = parseFloat(sliderX.input.value);
                        const y = parseFloat(sliderY.input.value);
                        const z = parseFloat(sliderZ.input.value);
                        return { X: x, Y: y, Z: z };
                    }

                    // D3 plot updater: draws Lorenz attractor as X vs Z phase plot
                    function updatePlot(times, Xseries, Yseries, Zseries) {
                        // Clear previous contents
                        while (svg.firstChild) svg.removeChild(svg.firstChild);

                        const margin = { top: 20, right: 20, bottom: 40, left: 50 };
                        const width = 760 - margin.left - margin.right;
                        const height = 320 - margin.top - margin.bottom;

                        const g = d3.select(svg)
                            .append('g')
                            .attr('transform', `translate(${margin.left},${margin.top})`);

                        // Prepare 2D points for X vs Z
                        const points = Xseries.map((x, i) => ({ x: x, z: Zseries[i], t: times[i] }));

                        const xExtent = d3.extent(points, d => d.x);
                        const zExtent = d3.extent(points, d => d.z);

                        // Add small padding
                        const xPad = (xExtent[1] - xExtent[0]) * 0.1 || 1;
                        const zPad = (zExtent[1] - zExtent[0]) * 0.1 || 1;

                        const xScale = d3.scaleLinear().domain([xExtent[0] - xPad, xExtent[1] + xPad]).range([0, width]);
                        const yScale = d3.scaleLinear().domain([zExtent[0] - zPad, zExtent[1] + zPad]).range([height, 0]);

                        const xAxis = d3.axisBottom(xScale).ticks(6);
                        const yAxis = d3.axisLeft(yScale).ticks(6);

                        g.append('g')
                            .attr('transform', `translate(0,${height})`)
                            .call(xAxis);

                        g.append('g')
                            .call(yAxis);

                        // Axis labels
                        g.append('text')
                            .attr('x', width / 2)
                            .attr('y', height + 35)
                            .attr('text-anchor', 'middle')
                            .text('X');

                        g.append('text')
                            .attr('transform', 'rotate(-90)')
                            .attr('x', -height / 2)
                            .attr('y', -36)
                            .attr('text-anchor', 'middle')
                            .text('Z');

                        // Line for the trajectory
                        const line = d3.line()
                            .x(d => xScale(d.x))
                            .y(d => yScale(d.z));

                        g.append('path')
                            .datum(points)
                            .attr('fill', 'none')
                            .attr('stroke', '#1f77b4')
                            .attr('stroke-width', 1.5)
                            .attr('d', line);

                        // Draw a small circle for the current (last) point
                        const last = points[points.length - 1];
                        if (last) {
                            g.append('circle')
                                .attr('cx', xScale(last.x))
                                .attr('cy', yScale(last.z))
                                .attr('r', 3)
                                .attr('fill', '#d62728');
                        }
                    }

                    // Run the simulation and populate the results table + plot
                    function runSimulation(steps = 1000, timeStep = 0.01) {
                        // Reset table
                        tbody.innerHTML = '';

                        // Reset concentrations from sliders
                        const vals = readSliderValues();
                        state.setConcentrations({ X: [vals.X], Y: [vals.Y], Z: [vals.Z] });

                        let cumulativeTime = 0.0;

                        const times = [0.0];
                        const Xs = [vals.X];
                        const Ys = [vals.Y];
                        const Zs = [vals.Z];

                        for (let i = 0; i < steps; i++) {
                            micm.solve(state, timeStep);
                            cumulativeTime += timeStep;

                            const concentrations = state.getConcentrations();
                            function val(spec) {
                                const v = concentrations[spec];
                                if (Array.isArray(v)) return v[0];
                                return v;
                            }

                            const xVal = val('X');
                            const yVal = val('Y');
                            const zVal = val('Z');

                            times.push(cumulativeTime);
                            Xs.push(xVal);
                            Ys.push(yVal);
                            Zs.push(zVal);

                            const row = document.createElement('tr');
                            [cumulativeTime.toFixed(2), xVal, yVal, zVal].forEach(cellVal => {
                                const td = document.createElement('td');
                                td.textContent = String(cellVal);
                                td.style.border = '1px solid #ddd';
                                td.style.padding = '6px';
                                row.appendChild(td);
                            });
                            tbody.appendChild(row);
                        }

                        updatePlot(times, Xs, Ys, Zs);
                    }

                    // Wire sliders to rerun simulation on input
                    [sliderX, sliderY, sliderZ].forEach(s => {
                        s.input.addEventListener('input', () => {
                            s.valueSpan.textContent = s.input.value;
                            runSimulation();
                        });
                    });

                    // Initial run
                    runSimulation();
                } catch (err) {
                    const errDiv = document.createElement('div');
                    errDiv.className = 'error';
                    errDiv.innerHTML = `<h2>❌ Simulation Error</h2><p>${err.message}</p>`;
                    contentDiv.appendChild(errDiv);
                    console.error(err);
                }
            } catch (error) {
                contentDiv.innerHTML = `
                    <div class="error">
                        <h2>❌ Error Loading MUSICA WASM</h2>
                        <p>${error.message}</p>
                        <p>Make sure you've built the WASM module and are serving this page over HTTP (not file://).</p>
                    </div>
                `;
                console.error('Error:', error);
            }
        }

        // Start initialization when page loads
        initMUSICA();
    </script>
</body>

</html>